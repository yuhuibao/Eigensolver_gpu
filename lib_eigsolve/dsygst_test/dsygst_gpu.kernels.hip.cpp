// This file was generated by gpufort

#include "hip/hip_complex.h"
#include "hip/hip_runtime.h"
#include "hip/math_functions.h"
#include <cstdio>

namespace {
// make float
float make_float(short int a) { return static_cast<float>(a); }
float make_float(unsigned short int a) { return static_cast<float>(a); }
float make_float(unsigned int a) { return static_cast<float>(a); }
float make_float(int a) { return static_cast<float>(a); }
float make_float(long int a) { return static_cast<float>(a); }
float make_float(unsigned long int a) { return static_cast<float>(a); }
float make_float(long long int a) { return static_cast<float>(a); }
float make_float(unsigned long long int a) { return static_cast<float>(a); }
float make_float(signed char a) { return static_cast<float>(a); }
float make_float(unsigned char a) { return static_cast<float>(a); }
float make_float(float a) { return static_cast<float>(a); }
float make_float(double a) { return static_cast<float>(a); }
float make_float(long double a) { return static_cast<float>(a); }
float make_float(hipFloatComplex &a) { return static_cast<float>(a.x); }
float make_float(hipDoubleComplex &a) { return static_cast<float>(a.x); }
// make double
double make_double(short int a) { return static_cast<double>(a); }
double make_double(unsigned short int a) { return static_cast<double>(a); }
double make_double(unsigned int a) { return static_cast<double>(a); }
double make_double(int a) { return static_cast<double>(a); }
double make_double(long int a) { return static_cast<double>(a); }
double make_double(unsigned long int a) { return static_cast<double>(a); }
double make_double(long long int a) { return static_cast<double>(a); }
double make_double(unsigned long long int a) { return static_cast<double>(a); }
double make_double(signed char a) { return static_cast<double>(a); }
double make_double(unsigned char a) { return static_cast<double>(a); }
double make_double(float a) { return static_cast<double>(a); }
double make_double(double a) { return static_cast<double>(a); }
double make_double(long double a) { return static_cast<double>(a); }
double make_double(hipFloatComplex &a) { return static_cast<double>(a.x); }
double make_double(hipDoubleComplex &a) { return static_cast<double>(a.x); }
// conjugate complex type
hipFloatComplex conj(hipFloatComplex &c) { return hipConjf(c); }
hipDoubleComplex conj(hipDoubleComplex &z) { return hipConj(z); }

// TODO Add the following functions:
// - sign(x,y) = sign(y) * |x| - sign transfer function
// ...
} // namespace
#define divideAndRoundUp(x, y) ((x) / (y) + ((x) % (y) != 0))
#undef _idx
#undef _idx_a
#undef _idx_a_s
#define _idx(a) ((a - 1))
#define _idx_a(a, b) ((a - 1) + n * (b - 1))
#define _idx_a_s(a, b) ((a - 1) + a_s_n1 * (b - 1))
// BEGIN krnl_afb01f_0
/* Fortran original:
        ! kernel do(2) <<<*,*, 0, stream1>>>
        do j = k, k + kb - 1
           do i = k, k + kb - 1
              if (j < i) then
                 A(i, j) = A(j, i)
              endif
           end do
        end do

*/
// NOTE: The following information was given in the orignal Cuf kernel pragma:
// - Nested outer-most do-loops that are directly mapped to threads: 2
// - Number of blocks (CUDA): [-1, -1, -1]. ('-1' means not specified)
// - Threads per block (CUDA): [-1, -1, -1]. ('-1' means not specified)
// - Shared Memory: 0
// - Stream: stream1

__global__ void krnl_afb01f_0(int kb, double *a, int k, int n) {

  
  /* unsigned int j = threadIdx.y + blockIdx.y * blockDim.y;
  unsigned int i = threadIdx.x + blockIdx.x * blockDim.x;
  k = k-1;
  if (j >= k && j <= (k + kb - 1) && i >= k && i <= (k + kb - 1)) {
    if ((j < i)) {
      *(a+i+j*n) = *(a+j+i*n);
    }
  } */
  /* unsigned int j = k + threadIdx.y + blockIdx.y * blockDim.y;
  unsigned int i = k + threadIdx.x + blockIdx.x * blockDim.x;
  if ((j <= (k + kb - 1)) && (i <= (k + kb - 1)) ){
    if ((j < i)){
        a[_idx_a(i,j)] = a[_idx_a(j,i)];
    } */
  k = k - 1;
  unsigned int j = k + threadIdx.y + blockIdx.y * blockDim.y;
  unsigned int i = k + threadIdx.x + blockIdx.x * blockDim.x;
  if ((j <= (k + kb - 1)) && (i <= (k + kb - 1)) ){
    if ((j < i)) {
      *(a+i+j*n) = *(a+j+i*n);
    }
  }

}

extern "C" void
launch_krnl_afb01f_0(dim3 *grid, dim3 *block, const int sharedMem, hipStream_t stream, int kb, double *a, int k, int N) {
  hipLaunchKernelGGL((krnl_afb01f_0), *grid, *block, sharedMem, stream, kb, a, k,N);
}
extern "C" void launch_krnl_afb01f_0_auto(int sharedMem, hipStream_t stream, int kb, double **a, int k,int N) {
//   const unsigned int krnl_afb01f_0_NX = kb;
//   const unsigned int krnl_afb01f_0_NY = kb;

  const unsigned int krnl_afb01f_0_NX = N;
  const unsigned int krnl_afb01f_0_NY = N;

  const unsigned int krnl_afb01f_0_blockX = 16;
  const unsigned int krnl_afb01f_0_blockY = 16;

  const unsigned int krnl_afb01f_0_gridX = divideAndRoundUp(krnl_afb01f_0_NX, krnl_afb01f_0_blockX);
  const unsigned int krnl_afb01f_0_gridY = divideAndRoundUp(krnl_afb01f_0_NY, krnl_afb01f_0_blockY);

  printf("%d, %d\n", krnl_afb01f_0_gridX, krnl_afb01f_0_gridY);

  dim3 grid(krnl_afb01f_0_gridX, krnl_afb01f_0_gridY);
  dim3 block(krnl_afb01f_0_blockX, krnl_afb01f_0_blockY);
  hipLaunchKernelGGL((krnl_afb01f_0), grid, block, sharedMem, stream, kb, *a, k,N);
}
// END krnl_afb01f_0
