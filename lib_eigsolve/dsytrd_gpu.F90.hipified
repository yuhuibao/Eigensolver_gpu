!
! Copyright (c) 2016, NVIDIA CORPORATION. All rights reserved.
!
!
! Permission is hereby granted, free of charge, to any person obtaining a
! copy of this software and associated documentation files (the "Software"),
! to deal in the Software without restriction, including without limitation
! the rights to use, copy, modify, merge, publish, distribute, sublicense,
! and/or sell copies of the Software, and to permit persons to whom the
! Software is furnished to do so, subject to the following conditions:
!
! The above copyright notice and this permission notice shall be included in
! all copies or substantial portions of the Software.
!
! THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
! IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
! FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
! THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
! LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
! FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
! DEALINGS IN THE SOFTWARE.
!

module dsytrd_gpu
   use dsytrd_gpu_kernels
   use hip
   use iso_c_binding
   use iso_c_binding_ext
   use hipblas

contains

   subroutine dsytrd_gpu(uplo, N, A, lda, d, e, tau, work, lwork, nb)
      use dsytrd_gpu_kernels
      use eigsolve_vars

      use dsytd2_gpu
      implicit none
      character                                 :: uplo
      integer                                   :: N, lda, lwork, nb, nx, ldwork, istat
      integer                                   :: i, j, k, kk
      type(c_ptr) :: d = c_null_ptr
      integer(c_int) :: d_n1 = N, d_lb1 = 1
      type(c_ptr) :: e = c_null_ptr
      integer(c_int) :: e_n1 = (N - 1), e_lb1 = 1
      type(c_ptr) :: work = c_null_ptr
      integer(c_int) :: work_n1 = lwork, work_lb1 = 1
      type(c_ptr) :: A = c_null_ptr
      integer(c_int) :: A_n1 = lda, A_n2 = N, A_lb1 = 1, A_lb2 = 1
      type(c_ptr) :: tau = c_null_ptr
      integer(c_int) :: tau_n1 = (N - 1), tau_lb1 = 1

      real(8), parameter                        :: one = 1.0_8
      type(dim3)                                :: threads

      type(c_ptr) :: hipblasHandle = c_null_ptr

      if (uplo .ne. 'U') then
         print *, "Provided uplo type not supported!"
         return
      endif

      if (lwork < (nb + 2)*N .and. N > nb) then
         write (*, *), "Provided work array must be sized (nb+2)*N or greater!"
         return
      endif

      ldwork = N

      hipblasCreate(hipblasHandle)
      istat = hipblasSetStream(hipblasHandle, cuHandle, stream1)

      kk = N - ((N - 32)/nb)*nb
      k = N + 1
      do i = N - nb + 1, kk + 1, -nb
         ! Reduce columns i:i+nb-1 to tridiagonal form
         call dlatrd_gpu(uplo, i + nb - 1, nb, A, lda, e, tau, work, ldwork)

         ! Update trailing submatrix
         call hipblasdsyr2k(hipblasHandle, uplo, HIPBLAS_OP_N, (i - 1), nb, -one, A(1, i), lda, work, ldwork, one, a, lda)

         k = k - nb

      end do

      ! Finish any remaining columns to get final 32x32 block
      nb = k - 32 - 1
      i = k - nb

      if (nb > 0) then
         ! Reduce columns i:i+nb-1 to tridiagonal form
         call dlatrd_gpu(uplo, i + nb - 1, nb, A, lda, e, tau, work, ldwork)

         ! Update trailing submatrix
         call hipblasdsyr2k(hipblasHandle, uplo, HIPBLAS_OP_N, (i - 1), nb, -one, A(1, i), lda, work, ldwork, one, a, lda)
         hipblasDestroy(hipblasHandle)

      endif

      ! Final block
      threads = dim3(32, 32, 1)
      call dsytd2_gpu<<<1, threads>>>(min(32, N), A, lda, d, e, tau)

      ! Copy superdiagonal back into A, store diagonal in d
      ! extracted to HIP C++ file
      ! TODO(gpufort) fix arguments
      CALL launch_krnl_2b8e8f_0_auto(0, c_null_ptr, n, d, d_n1, d_lb1, a, a_n1, a_n2, a_lb1, a_lb2)

   end subroutine dsytrd_gpu

   subroutine dlatrd_gpu(uplo, N, nb, A, lda, e, tau, W, ldw)
      use dsytrd_gpu_kernels
      use eigsolve_vars

      use dsymv_gpu_kernels
      implicit none
      character                                  :: uplo
      integer                                    :: N, nb, lda, ldw, istat
      integer                                    :: i, j, k, iw
      integer                                    :: blocks, threads
      type(c_ptr) :: A = c_null_ptr
      integer(c_int) :: A_n1 = lda, A_n2 = N, A_lb1 = 1, A_lb2 = 1
      type(c_ptr) :: W = c_null_ptr
      integer(c_int) :: W_n1 = ldw, W_n2 = nb, W_lb1 = 1, W_lb2 = 1
      type(c_ptr) :: tau = c_null_ptr
      integer(c_int) :: tau_n1 = (N - 1), tau_lb1 = 1
      type(c_ptr) :: e = c_null_ptr
      integer(c_int) :: e_n1 = (N - 1), e_lb1 = 1

      real(8), parameter                         :: one = 1.0d0, zero = 0.0d0, half = 0.5d0

      type(dim3)                                 :: threads2D, blocks2D

      if (uplo .ne. 'U') then
         print *, "Provided uplo type not supported!"
         return
      endif

      threads2D = dim3(32, 8, 1)
      threads = 256

      if (N <= 0) return

      ! Complete first iteration outside loop
      if (N > 1) then
         iw = nb
         ! Generate elementary reflector H(i) to annihilate A(1:i-2, i)
         CALL launch_dlarfg_kernel(1, threads, 0, c_null_ptr,N - 1, e(N - 1), A(1, N), tau(N - 1))
         ! extracted to HIP C++ file
         ! TODO(gpufort) fix arguments
         CALL launch_krnl_37a79c_1_auto(0, c_null_ptr, w, w_n1, w_n2, w_lb1, w_lb2, n, iw)

         blocks2D = dim3(10, ceiling(real(N - 1)/32), 1) !JR TODO: What is optimal number of columns for our problem size?
         CALL launch_dsymv_gpu(blocks2D, threads2D, 0, hipDefaultStream, N-1, A, lda, A(1, N), W(1, iw))

         call finish_W_col_kernel<<<1, threads>>>(N - 1, tau(N - 1), A(1, N), W(1, iw))
      endif

      do i = N - 1, N - nb + 1, -1
         iw = i - N + nb

         blocks2D = dim3(ceiling(real(max(i, N - i))/32), ceiling(real(N - i)/8), 1)
         !call dsyr2_mv_kernel<<<blocks2D, threads2D>>>(i, N-i, A(1, i+1), lda, W(1, iw+1), ldw, A(1, i), W(1, iw), ldw)
         CALL launch_dsyr2_mv_dlarfg_kernel(blocks2D, threads2D, 0, hipDefaultStream, i, N - i, A

         if (i > 1) then
            ! Generate elementary reflector H(i) to annihilate A(1:i-2, i)
            !call dlarfg_kernel<<<1, threads>>>(i-1, e(i-1), A(1, i), tau(i-1))

            blocks2D = dim3(10, ceiling(real(i - 1)/32), 1) !JR TODO: What is optimal number of columns for our problem size?
            CALL launch_dsymv_gpu(blocks2D, threads2D, 0, hipDefaultStream, i - 1, A, lda, A

            blocks2D = dim3(ceiling(real(i - 1)/32), ceiling(real(2*(n - i))/8), 1)
            CALL launch_stacked_dgemv_T(blocks2D, threads2D, 0, hipDefaultStream, n - i, i - 1, A
            !call stacked_dgemv_N<<<blocks2D, threads2D>>>(i-1, n-i, A(1,i+1), lda, W(1, iw+1), ldw, W(i+1,iw), W(i+1, iw+1), W(1, iw))
            CALL launch_stacked_dgemv_N_finish_W(blocks2D, threads2D, 0, hipDefaultStream, i - 1, n - i, A

            !call finish_W_col_kernel<<<1, threads>>>(i-1, tau(i-1), A(1, i), W(1, iw))

         end if
      end do
   end subroutine dlatrd_gpu

   ! extracted to HIP C++ file

   ! extracted to HIP C++ file

   ! extracted to HIP C++ file

   ! extracted to HIP C++ file

   ! extracted to HIP C++ file

   ! extracted to HIP C++ file

   ! extracted to HIP C++ file

end module dsytrd_gpu

