! This file was generated by gpufort
          
           
module dsytrd_gpu_kernels
  use hip
  implicit none

 
  interface

    subroutine launch_krnl_2b8e8f_0(grid,&
        block,&
        sharedMem,&
        stream,&
        n,&
        d,&
        d_n1,&
        d_lb1,&
        a,&
        a_n1,&
        a_n2,&
        a_lb1,&
        a_lb2) bind(c, name="launch_krnl_2b8e8f_0")
      use iso_c_binding
      use hip
      implicit none
      type(dim3),intent(IN) :: grid
      type(dim3),intent(IN) :: block
      integer(c_int),intent(IN) :: sharedMem
      type(c_ptr),value,intent(IN) :: stream
      INTEGER(kind=),value :: n
      type(c_ptr),value :: d
      integer(c_int),value,intent(IN) :: d_n1
      integer(c_int),value,intent(IN) :: d_lb1
      type(c_ptr),value :: a
      integer(c_int),value,intent(IN) :: a_n1
      integer(c_int),value,intent(IN) :: a_n2
      integer(c_int),value,intent(IN) :: a_lb1
      integer(c_int),value,intent(IN) :: a_lb2
    end subroutine

    subroutine launch_krnl_2b8e8f_0_auto(sharedMem,&
        stream,&
        n,&
        d,&
        d_n1,&
        d_lb1,&
        a,&
        a_n1,&
        a_n2,&
        a_lb1,&
        a_lb2) bind(c, name="launch_krnl_2b8e8f_0_auto")
      use iso_c_binding
      use hip
      implicit none
      integer(c_int),intent(IN) :: sharedMem
      type(c_ptr),value,intent(IN) :: stream
      INTEGER(kind=),value :: n
      type(c_ptr),value :: d
      integer(c_int),value,intent(IN) :: d_n1
      integer(c_int),value,intent(IN) :: d_lb1
      type(c_ptr),value :: a
      integer(c_int),value,intent(IN) :: a_n1
      integer(c_int),value,intent(IN) :: a_n2
      integer(c_int),value,intent(IN) :: a_lb1
      integer(c_int),value,intent(IN) :: a_lb2
    end subroutine

    subroutine launch_krnl_37a79c_1(grid,&
        block,&
        sharedMem,&
        stream,&
        w,&
        w_n1,&
        w_n2,&
        w_lb1,&
        w_lb2,&
        n,&
        iw) bind(c, name="launch_krnl_37a79c_1")
      use iso_c_binding
      use hip
      implicit none
      type(dim3),intent(IN) :: grid
      type(dim3),intent(IN) :: block
      integer(c_int),intent(IN) :: sharedMem
      type(c_ptr),value,intent(IN) :: stream
      type(c_ptr),value :: w
      integer(c_int),value,intent(IN) :: w_n1
      integer(c_int),value,intent(IN) :: w_n2
      integer(c_int),value,intent(IN) :: w_lb1
      integer(c_int),value,intent(IN) :: w_lb2
      INTEGER(kind=),value :: n
      INTEGER(kind=),value :: iw
    end subroutine

    subroutine launch_krnl_37a79c_1_auto(sharedMem,&
        stream,&
        w,&
        w_n1,&
        w_n2,&
        w_lb1,&
        w_lb2,&
        n,&
        iw) bind(c, name="launch_krnl_37a79c_1_auto")
      use iso_c_binding
      use hip
      implicit none
      integer(c_int),intent(IN) :: sharedMem
      type(c_ptr),value,intent(IN) :: stream
      type(c_ptr),value :: w
      integer(c_int),value,intent(IN) :: w_n1
      integer(c_int),value,intent(IN) :: w_n2
      integer(c_int),value,intent(IN) :: w_lb1
      integer(c_int),value,intent(IN) :: w_lb2
      INTEGER(kind=),value :: n
      INTEGER(kind=),value :: iw
    end subroutine

    subroutine launch_dsyr2_mv_kernel(grid,&
        block,&
        sharedMem,&
        stream,&
        n,&
        m,&
        ldv,&
        ldw,&
        ldw2,&
        v,&
        v_n1,&
        v_n2,&
        v_lb1,&
        v_lb2,&
        w,&
        w_n1,&
        w_n2,&
        w_lb1,&
        w_lb2,&
        w2,&
        w2_n1,&
        w2_n2,&
        w2_lb1,&
        w2_lb2,&
        x,&
        x_n1,&
        x_lb1) bind(c, name="launch_dsyr2_mv_kernel")
      use iso_c_binding
      use hip
      implicit none
      type(dim3,,intent(IN, :: grid
      type(dim3,,intent(IN, :: block
      integer(c_int,,intent(IN, :: sharedMem
      type(c_ptr,,value,intent(IN, :: stream
      INTEGER(kind=),value :: n
      INTEGER(kind=),value :: m
      INTEGER(kind=),value :: ldv
      INTEGER(kind=),value :: ldw
      INTEGER(kind=),value :: ldw2
      type(c_ptr),value :: _v
      integer(c_int),value,intent(IN) :: v_n1
      integer(c_int),value,intent(IN) :: v_n2
      integer(c_int),value,intent(IN) :: v_lb1
      integer(c_int),value,intent(IN) :: v_lb2
      type(c_ptr),value :: _w
      integer(c_int),value,intent(IN) :: w_n1
      integer(c_int),value,intent(IN) :: w_n2
      integer(c_int),value,intent(IN) :: w_lb1
      integer(c_int),value,intent(IN) :: w_lb2
      type(c_ptr),value :: _w2
      integer(c_int),value,intent(IN) :: w2_n1
      integer(c_int),value,intent(IN) :: w2_n2
      integer(c_int),value,intent(IN) :: w2_lb1
      integer(c_int),value,intent(IN) :: w2_lb2
      type(c_ptr),value :: _x
      integer(c_int),value,intent(IN) :: x_n1
      integer(c_int),value,intent(IN) :: x_lb1
    end subroutine

    subroutine launch_dlarfg_kernel(grid,&
        block,&
        sharedMem,&
        stream,&
        n,&
        tau,&
        e,&
        x,&
        x_n1,&
        x_lb1) bind(c, name="launch_dlarfg_kernel")
      use iso_c_binding
      use hip
      implicit none
      type(dim3,,intent(IN, :: grid
      type(dim3,,intent(IN, :: block
      integer(c_int,,intent(IN, :: sharedMem
      type(c_ptr,,value,intent(IN, :: stream
      INTEGER(kind=),value :: n
      REAL(kind=8),value :: tau
      REAL(kind=8),value :: e
      type(c_ptr),value :: _x
      integer(c_int),value,intent(IN) :: x_n1
      integer(c_int),value,intent(IN) :: x_lb1
    end subroutine

    subroutine launch_dsyr2_mv_dlarfg_kernel(grid,&
        block,&
        sharedMem,&
        stream,&
        n,&
        m,&
        ldv,&
        ldw,&
        ldw2,&
        v,&
        v_n1,&
        v_n2,&
        v_lb1,&
        v_lb2,&
        w,&
        w_n1,&
        w_n2,&
        w_lb1,&
        w_lb2,&
        w2,&
        w2_n1,&
        w2_n2,&
        w2_lb1,&
        w2_lb2,&
        x,&
        x_n1,&
        x_lb1,&
        tau,&
        e,&
        finished) bind(c, name="launch_dsyr2_mv_dlarfg_kernel")
      use iso_c_binding
      use hip
      implicit none
      type(dim3,,intent(IN, :: grid
      type(dim3,,intent(IN, :: block
      integer(c_int,,intent(IN, :: sharedMem
      type(c_ptr,,value,intent(IN, :: stream
      INTEGER(kind=),value :: n
      INTEGER(kind=),value :: m
      INTEGER(kind=),value :: ldv
      INTEGER(kind=),value :: ldw
      INTEGER(kind=),value :: ldw2
      type(c_ptr),value :: _v
      integer(c_int),value,intent(IN) :: v_n1
      integer(c_int),value,intent(IN) :: v_n2
      integer(c_int),value,intent(IN) :: v_lb1
      integer(c_int),value,intent(IN) :: v_lb2
      type(c_ptr),value :: _w
      integer(c_int),value,intent(IN) :: w_n1
      integer(c_int),value,intent(IN) :: w_n2
      integer(c_int),value,intent(IN) :: w_lb1
      integer(c_int),value,intent(IN) :: w_lb2
      type(c_ptr),value :: _w2
      integer(c_int),value,intent(IN) :: w2_n1
      integer(c_int),value,intent(IN) :: w2_n2
      integer(c_int),value,intent(IN) :: w2_lb1
      integer(c_int),value,intent(IN) :: w2_lb2
      type(c_ptr),value :: _x
      integer(c_int),value,intent(IN) :: x_n1
      integer(c_int),value,intent(IN) :: x_lb1
      REAL(kind=8),value :: tau
      REAL(kind=8),value :: e
      INTEGER(kind=),value :: finished
    end subroutine

    subroutine launch_stacked_dgemv_t(grid,&
        block,&
        sharedMem,&
        stream,&
        m,&
        n,&
        ldv,&
        ldw,&
        v,&
        v_n1,&
        v_n2,&
        v_lb1,&
        v_lb2,&
        w,&
        w_n1,&
        w_n2,&
        w_lb1,&
        w_lb2,&
        x,&
        x_n1,&
        x_lb1,&
        z1,&
        z1_n1,&
        z1_lb1,&
        z2,&
        z2_n1,&
        z2_lb1) bind(c, name="launch_stacked_dgemv_t")
      use iso_c_binding
      use hip
      implicit none
      type(dim3,,intent(IN, :: grid
      type(dim3,,intent(IN, :: block
      integer(c_int,,intent(IN, :: sharedMem
      type(c_ptr,,value,intent(IN, :: stream
      INTEGER(kind=),value :: m
      INTEGER(kind=),value :: n
      INTEGER(kind=),value :: ldv
      INTEGER(kind=),value :: ldw
      type(c_ptr),value :: _v
      integer(c_int),value,intent(IN) :: v_n1
      integer(c_int),value,intent(IN) :: v_n2
      integer(c_int),value,intent(IN) :: v_lb1
      integer(c_int),value,intent(IN) :: v_lb2
      type(c_ptr),value :: _w
      integer(c_int),value,intent(IN) :: w_n1
      integer(c_int),value,intent(IN) :: w_n2
      integer(c_int),value,intent(IN) :: w_lb1
      integer(c_int),value,intent(IN) :: w_lb2
      type(c_ptr),value :: _x
      integer(c_int),value,intent(IN) :: x_n1
      integer(c_int),value,intent(IN) :: x_lb1
      type(c_ptr),value :: _z1
      integer(c_int),value,intent(IN) :: z1_n1
      integer(c_int),value,intent(IN) :: z1_lb1
      type(c_ptr),value :: _z2
      integer(c_int),value,intent(IN) :: z2_n1
      integer(c_int),value,intent(IN) :: z2_lb1
    end subroutine

    subroutine launch_stacked_dgemv_n(grid,&
        block,&
        sharedMem,&
        stream,&
        m,&
        n,&
        ldv,&
        ldw,&
        v,&
        v_n1,&
        v_n2,&
        v_lb1,&
        v_lb2,&
        w,&
        w_n1,&
        w_n2,&
        w_lb1,&
        w_lb2,&
        z1,&
        z1_n1,&
        z1_lb1,&
        z2,&
        z2_n1,&
        z2_lb1,&
        y,&
        y_n1,&
        y_lb1) bind(c, name="launch_stacked_dgemv_n")
      use iso_c_binding
      use hip
      implicit none
      type(dim3,,intent(IN, :: grid
      type(dim3,,intent(IN, :: block
      integer(c_int,,intent(IN, :: sharedMem
      type(c_ptr,,value,intent(IN, :: stream
      INTEGER(kind=),value :: m
      INTEGER(kind=),value :: n
      INTEGER(kind=),value :: ldv
      INTEGER(kind=),value :: ldw
      type(c_ptr),value :: _v
      integer(c_int),value,intent(IN) :: v_n1
      integer(c_int),value,intent(IN) :: v_n2
      integer(c_int),value,intent(IN) :: v_lb1
      integer(c_int),value,intent(IN) :: v_lb2
      type(c_ptr),value :: _w
      integer(c_int),value,intent(IN) :: w_n1
      integer(c_int),value,intent(IN) :: w_n2
      integer(c_int),value,intent(IN) :: w_lb1
      integer(c_int),value,intent(IN) :: w_lb2
      type(c_ptr),value :: _z1
      integer(c_int),value,intent(IN) :: z1_n1
      integer(c_int),value,intent(IN) :: z1_lb1
      type(c_ptr),value :: _z2
      integer(c_int),value,intent(IN) :: z2_n1
      integer(c_int),value,intent(IN) :: z2_lb1
      type(c_ptr),value :: _y
      integer(c_int),value,intent(IN) :: y_n1
      integer(c_int),value,intent(IN) :: y_lb1
    end subroutine

    subroutine launch_finish_w_col_kernel(grid,&
        block,&
        sharedMem,&
        stream,&
        n,&
        tau,&
        x,&
        x_n1,&
        x_lb1,&
        y,&
        y_n1,&
        y_lb1) bind(c, name="launch_finish_w_col_kernel")
      use iso_c_binding
      use hip
      implicit none
      type(dim3,,intent(IN, :: grid
      type(dim3,,intent(IN, :: block
      integer(c_int,,intent(IN, :: sharedMem
      type(c_ptr,,value,intent(IN, :: stream
      INTEGER(kind=),value :: n
      REAL(kind=8),value :: tau
      type(c_ptr),value :: _x
      integer(c_int),value,intent(IN) :: x_n1
      integer(c_int),value,intent(IN) :: x_lb1
      type(c_ptr),value :: _y
      integer(c_int),value,intent(IN) :: y_n1
      integer(c_int),value,intent(IN) :: y_lb1
    end subroutine

    subroutine launch_stacked_dgemv_n_finish_w(grid,&
        block,&
        sharedMem,&
        stream,&
        m,&
        n,&
        ldv,&
        ldw,&
        v,&
        v_n1,&
        v_n2,&
        v_lb1,&
        v_lb2,&
        w,&
        w_n1,&
        w_n2,&
        w_lb1,&
        w_lb2,&
        z1,&
        z1_n1,&
        z1_lb1,&
        z2,&
        z2_n1,&
        z2_lb1,&
        y,&
        y_n1,&
        y_lb1,&
        tau,&
        x,&
        x_n1,&
        x_lb1,&
        finished) bind(c, name="launch_stacked_dgemv_n_finish_w")
      use iso_c_binding
      use hip
      implicit none
      type(dim3,,intent(IN, :: grid
      type(dim3,,intent(IN, :: block
      integer(c_int,,intent(IN, :: sharedMem
      type(c_ptr,,value,intent(IN, :: stream
      INTEGER(kind=),value :: m
      INTEGER(kind=),value :: n
      INTEGER(kind=),value :: ldv
      INTEGER(kind=),value :: ldw
      type(c_ptr),value :: _v
      integer(c_int),value,intent(IN) :: v_n1
      integer(c_int),value,intent(IN) :: v_n2
      integer(c_int),value,intent(IN) :: v_lb1
      integer(c_int),value,intent(IN) :: v_lb2
      type(c_ptr),value :: _w
      integer(c_int),value,intent(IN) :: w_n1
      integer(c_int),value,intent(IN) :: w_n2
      integer(c_int),value,intent(IN) :: w_lb1
      integer(c_int),value,intent(IN) :: w_lb2
      type(c_ptr),value :: _z1
      integer(c_int),value,intent(IN) :: z1_n1
      integer(c_int),value,intent(IN) :: z1_lb1
      type(c_ptr),value :: _z2
      integer(c_int),value,intent(IN) :: z2_n1
      integer(c_int),value,intent(IN) :: z2_lb1
      type(c_ptr),value :: _y
      integer(c_int),value,intent(IN) :: y_n1
      integer(c_int),value,intent(IN) :: y_lb1
      REAL(kind=8),value :: tau
      type(c_ptr),value :: _x
      integer(c_int),value,intent(IN) :: x_n1
      integer(c_int),value,intent(IN) :: x_lb1
      INTEGER(kind=),value :: finished
    end subroutine

  end interface

  contains

    subroutine launch_krnl_2b8e8f_0_cpu(sharedMem,&
        stream,&
        n,&
        _d,&
        d_n1,&
        d_lb1,&
        _a,&
        a_n1,&
        a_n2,&
        a_lb1,&
        a_lb2)
      use iso_c_binding
      use hip
      implicit none
      integer(c_int),intent(IN) :: sharedMem
      type(c_ptr),value,intent(IN) :: stream
      INTEGER(kind=),value :: n
      type(c_ptr),value :: _d
      integer(c_int),value,intent(IN) :: d_n1
      integer(c_int),value,intent(IN) :: d_lb1
      type(c_ptr),value :: _a
      integer(c_int),value,intent(IN) :: a_n1
      integer(c_int),value,intent(IN) :: a_n2
      integer(c_int),value,intent(IN) :: a_lb1
      integer(c_int),value,intent(IN) :: a_lb2
            real(8),target :: d(d_n1)
            real(8), 1:N),target :: a(a_n1,a_n2)
      INTEGER(kind=) :: j
      CALL hipCheck(hipMemcpy(c_loc(d),_d,C_SIZEOF(d),hipMemcpyDeviceToHost))
      CALL hipCheck(hipMemcpy(c_loc(a),_a,C_SIZEOF(a),hipMemcpyDeviceToHost))
      do j = 33, N
      !A(j-1, j) = e(j-1) ! JR Not strictly needed so skipping this copy
         d(j) = A(j, j)
      end do
      CALL hipCheck(hipMemcpy(_d,c_loc(d),C_SIZEOF(d),hipMemcpyHostToDevice))
      CALL hipCheck(hipMemcpy(_a,c_loc(a),C_SIZEOF(a),hipMemcpyHostToDevice))

    end subroutine

    subroutine launch_krnl_37a79c_1_cpu(sharedMem,&
        stream,&
        _w,&
        w_n1,&
        w_n2,&
        w_lb1,&
        w_lb2,&
        n,&
        iw)
      use iso_c_binding
      use hip
      implicit none
      integer(c_int),intent(IN) :: sharedMem
      type(c_ptr),value,intent(IN) :: stream
      type(c_ptr),value :: _w
      integer(c_int),value,intent(IN) :: w_n1
      integer(c_int),value,intent(IN) :: w_n2
      integer(c_int),value,intent(IN) :: w_lb1
      integer(c_int),value,intent(IN) :: w_lb2
      INTEGER(kind=),value :: n
      INTEGER(kind=),value :: iw
            real(8), 1:nb),target :: w(w_n1,w_n2)
      INTEGER(kind=) :: k
      CALL hipCheck(hipMemcpy(c_loc(w),_w,C_SIZEOF(w),hipMemcpyDeviceToHost))
      do k = 1, N - 1
         W(k, iw) = 0.d0
      end do
      CALL hipCheck(hipMemcpy(_w,c_loc(w),C_SIZEOF(w),hipMemcpyHostToDevice))

    end subroutine

    subroutine launch_dsyr2_mv_kernel_cpu(n,&
        m,&
        ldv,&
        ldw,&
        ldw2,&
        _v,&
        v_n1,&
        v_n2,&
        v_lb1,&
        v_lb2,&
        _w,&
        w_n1,&
        w_n2,&
        w_lb1,&
        w_lb2,&
        _w2,&
        w2_n1,&
        w2_n2,&
        w2_lb1,&
        w2_lb2,&
        _x,&
        x_n1,&
        x_lb1)
      use iso_c_binding
      use hip
      implicit none
      INTEGER(kind=),value :: n
      INTEGER(kind=),value :: m
      INTEGER(kind=),value :: ldv
      INTEGER(kind=),value :: ldw
      INTEGER(kind=),value :: ldw2
      type(c_ptr),value :: _v
      integer(c_int),value,intent(IN) :: v_n1
      integer(c_int),value,intent(IN) :: v_n2
      integer(c_int),value,intent(IN) :: v_lb1
      integer(c_int),value,intent(IN) :: v_lb2
      type(c_ptr),value :: _w
      integer(c_int),value,intent(IN) :: w_n1
      integer(c_int),value,intent(IN) :: w_n2
      integer(c_int),value,intent(IN) :: w_lb1
      integer(c_int),value,intent(IN) :: w_lb2
      type(c_ptr),value :: _w2
      integer(c_int),value,intent(IN) :: w2_n1
      integer(c_int),value,intent(IN) :: w2_n2
      integer(c_int),value,intent(IN) :: w2_lb1
      integer(c_int),value,intent(IN) :: w2_lb2
      type(c_ptr),value :: _x
      integer(c_int),value,intent(IN) :: x_n1
      integer(c_int),value,intent(IN) :: x_lb1
            real(8), 1:M), intent(in)  ,target :: v(v_n1,v_n2)
            real(8), 1:M), intent(in)  ,target :: w(w_n1,w_n2)
            real(8), 2),target :: w2(w2_n1,w2_n2)
            real(8),target :: x(x_n1)
      CALL hipCheck(hipMemcpy(c_loc(v),_v,C_SIZEOF(v),hipMemcpyDeviceToHost))
      CALL hipCheck(hipMemcpy(c_loc(w),_w,C_SIZEOF(w),hipMemcpyDeviceToHost))
      CALL hipCheck(hipMemcpy(c_loc(w2),_w2,C_SIZEOF(w2),hipMemcpyDeviceToHost))
      CALL hipCheck(hipMemcpy(c_loc(x),_x,C_SIZEOF(x),hipMemcpyDeviceToHost))
            implicit none
            integer, value                                      :: N, M, ldv, ldw, ldw2
            real(8), dimension(1:ldv, 1:M), device, intent(in)  :: V
            real(8), dimension(1:ldw, 1:M), device, intent(in)  :: W
            real(8), dimension(1:ldw2, 2), device               :: W2
            real(8), dimension(1:N), device                     :: x

            integer                                             :: i, j, istat
            real(8)                                             :: rv

            i = (blockIdx%x - 1)*blockDim%x + threadIdx%x
            j = (blockIdx%y - 1)*blockDim%y + threadIdx%y

            if (i <= N .and. j <= M) then

               rv = -W(N, j)*V(i, j) - V(N, j)*W(i, j)

               ! Update x
               istat = atomicadd(x(i), rv)
            endif

            if (threadIdx%y == 1) then
               ! Zero out column for zhemv call
               if (i <= N) W2(i, 1) = 0
               ! Zero out workspace for intermediate zgemv results
               if (i <= M) then
                  W2(N + i, 1) = 0
                  W2(N + i, 2) = 0
               endif
            endif

      CALL hipCheck(hipMemcpy(_v,c_loc(v),C_SIZEOF(v),hipMemcpyHostToDevice))
      CALL hipCheck(hipMemcpy(_w,c_loc(w),C_SIZEOF(w),hipMemcpyHostToDevice))
      CALL hipCheck(hipMemcpy(_w2,c_loc(w2),C_SIZEOF(w2),hipMemcpyHostToDevice))
      CALL hipCheck(hipMemcpy(_x,c_loc(x),C_SIZEOF(x),hipMemcpyHostToDevice))

    end subroutine

    subroutine launch_dlarfg_kernel_cpu(n,&
        tau,&
        e,&
        _x,&
        x_n1,&
        x_lb1)
      use iso_c_binding
      use hip
      implicit none
      INTEGER(kind=),value :: n
      REAL(kind=8),value :: tau
      REAL(kind=8),value :: e
      type(c_ptr),value :: _x
      integer(c_int),value,intent(IN) :: x_n1
      integer(c_int),value,intent(IN) :: x_lb1
            real(8),target :: x(x_n1)
      CALL hipCheck(hipMemcpy(c_loc(x),_x,C_SIZEOF(x),hipMemcpyDeviceToHost))
            implicit none
            integer, value                   :: N
            real(8), device                  :: tau
            real(8), device                  :: e
            real(8), dimension(N), device    :: x

            integer                          :: tid, i, j, nb, istat, laneID
            real(8)                          :: rv1, rv2, rv3, scal, scal2, alphar, beta, rsum
            real(8), shared                  :: xnorm
            real(8), shared                  :: alpha_s

            tid = threadIdx%x
            laneID = iand(tid, 31)

            if (tid == 1) then
               alpha_s = x(N)
               xnorm = 0.0_8
            endif

            call syncthreads()

            alphar = alpha_s
            rsum = 0.0_8

            nb = ceiling(real(N)/blockDim%x) ! number of blocks down column

            i = tid
            do j = 1, nb

               ! All threads perform their product, zero if out of bounds
               if (i <= N - 1) then
                  rv1 = x(i)
                  rv1 = rv1*rv1
               else
                  rv1 = 0.0_8
               endif

               rsum = rsum + rv1

               i = i + blockDim%x
            end do

            ! Partial sum within warps using shuffle
            rv1 = rsum
            rv2 = __shfl_down(rv1, 1)
            rv1 = rv1 + rv2
            rv2 = __shfl_down(rv1, 2)
            rv1 = rv1 + rv2
            rv2 = __shfl_down(rv1, 4)
            rv1 = rv1 + rv2
            rv2 = __shfl_down(rv1, 8)
            rv1 = rv1 + rv2
            rv2 = __shfl_down(rv1, 16)
            rv1 = rv1 + rv2

            if (laneID == 1) then
               istat = atomicadd(xnorm, rv1)
            endif

            call syncthreads()

            if (xnorm == 0.0_8) then
               if (tid == 1) then
                  tau = 0.0_8
               endif
            else
               if (tid == 1) then
                  xnorm = sqrt(xnorm)
                  rv1 = abs(alphar)

                  ! not taking abs of xnorm
                  scal = max(rv1, xnorm)
                  scal2 = min(rv1, xnorm)

                  if (scal2 .eq. 0.0d0) then
                     beta = -sign(scal, alphar)
                  else
                     beta = -sign(scal*sqrt(1.0d0 + (scal2/scal)**2), alphar)
                  endif

                  tau = (beta - alphar)/beta

                  e = beta ! store beta in e vector
                  alpha_s = 1.d0/(alphar - beta) !scaling factor for dscal
               endif

               call syncthreads()

               do i = tid, N, blockDim%x

                  if (i <= N - 1) then
                     x(i) = alpha_s*x(i)
                  elseif (i == N) then
                     x(i) = 1.0_8
                  endif

               end do

            endif

      CALL hipCheck(hipMemcpy(_x,c_loc(x),C_SIZEOF(x),hipMemcpyHostToDevice))

    end subroutine

    subroutine launch_dsyr2_mv_dlarfg_kernel_cpu(n,&
        m,&
        ldv,&
        ldw,&
        ldw2,&
        _v,&
        v_n1,&
        v_n2,&
        v_lb1,&
        v_lb2,&
        _w,&
        w_n1,&
        w_n2,&
        w_lb1,&
        w_lb2,&
        _w2,&
        w2_n1,&
        w2_n2,&
        w2_lb1,&
        w2_lb2,&
        _x,&
        x_n1,&
        x_lb1,&
        tau,&
        e,&
        finished)
      use iso_c_binding
      use hip
      implicit none
      INTEGER(kind=),value :: n
      INTEGER(kind=),value :: m
      INTEGER(kind=),value :: ldv
      INTEGER(kind=),value :: ldw
      INTEGER(kind=),value :: ldw2
      type(c_ptr),value :: _v
      integer(c_int),value,intent(IN) :: v_n1
      integer(c_int),value,intent(IN) :: v_n2
      integer(c_int),value,intent(IN) :: v_lb1
      integer(c_int),value,intent(IN) :: v_lb2
      type(c_ptr),value :: _w
      integer(c_int),value,intent(IN) :: w_n1
      integer(c_int),value,intent(IN) :: w_n2
      integer(c_int),value,intent(IN) :: w_lb1
      integer(c_int),value,intent(IN) :: w_lb2
      type(c_ptr),value :: _w2
      integer(c_int),value,intent(IN) :: w2_n1
      integer(c_int),value,intent(IN) :: w2_n2
      integer(c_int),value,intent(IN) :: w2_lb1
      integer(c_int),value,intent(IN) :: w2_lb2
      type(c_ptr),value :: _x
      integer(c_int),value,intent(IN) :: x_n1
      integer(c_int),value,intent(IN) :: x_lb1
      REAL(kind=8),value :: tau
      REAL(kind=8),value :: e
      INTEGER(kind=),value :: finished
            real(8), 1:M), intent(in)  ,target :: v(v_n1,v_n2)
            real(8), 1:M), intent(in)  ,target :: w(w_n1,w_n2)
            real(8), 2),target :: w2(w2_n1,w2_n2)
            real(8),target :: x(x_n1)
      CALL hipCheck(hipMemcpy(c_loc(v),_v,C_SIZEOF(v),hipMemcpyDeviceToHost))
      CALL hipCheck(hipMemcpy(c_loc(w),_w,C_SIZEOF(w),hipMemcpyDeviceToHost))
      CALL hipCheck(hipMemcpy(c_loc(w2),_w2,C_SIZEOF(w2),hipMemcpyDeviceToHost))
      CALL hipCheck(hipMemcpy(c_loc(x),_x,C_SIZEOF(x),hipMemcpyDeviceToHost))
            implicit none
            integer, value                                      :: N, M, ldv, ldw, ldw2
            real(8), dimension(1:ldv, 1:M), device, intent(in)  :: V
            real(8), dimension(1:ldw, 1:M), device, intent(in)  :: W
            real(8), dimension(1:ldw2, 2), device               :: W2
            real(8), dimension(1:N), device                     :: x
            real(8), device                                     :: tau
            real(8), device                                     :: e

            integer                                             :: i, j, tx, ty, tid, nb, laneid, istat, nBlocks
            integer, device                                     :: finished
            integer, shared                                     :: nFinished
            real(8)                                             :: rv
            real(8)                                             :: rv1, rv2, rv3, scal, scal2, alphar, beta, rsum
            real(8), shared                                     :: xnorm
            real(8), shared                                     :: alpha_s

            tx = threadIdx%x
            ty = threadIdx%y
            i = (blockIdx%x - 1)*blockDim%x + tx
            j = (blockIdx%y - 1)*blockDim%y + ty

            nBlocks = gridDim%x*gridDim%y

            if (i <= N .and. j <= M) then

               rv = -W(N, j)*V(i, j) - V(N, j)*W(i, j)

               ! Update x
               istat = atomicadd(x(i), rv)
            endif

            if (ty == 1) then
               ! Zero out column for dgemv call
               if (i <= N) W2(i, 1) = 0
               ! Zero out workspace for intermediate dgemv results
               if (i <= M) then
                  W2(N + i, 1) = 0
                  W2(N + i, 2) = 0
               endif
            endif

            call threadfence()

            nFinished = 0
            call syncthreads()
            if (tx + ty == 2) nFinished = atomicinc(finished, nBlocks - 1)
            call syncthreads()

            if (nFinished < nBlocks - 1) return

            ! Begin dlarfg work with last block
            if (N == 1) return

            tid = tx + (ty - 1)*blockDim%x
            laneID = iand(tid, 31)

            if (tid == 1) then
               alpha_s = x(N - 1)
               xnorm = 0.0_8
            endif

            call syncthreads()

            alphar = alpha_s
            rsum = 0.0_8

            nb = ceiling(real(N - 1)/blockDim%x*blockDim%y) ! number of blocks down column

            i = tid
            do j = 1, nb

               ! All threads perform their product, zero if out of bounds
               if (i <= N - 2) then
                  rv1 = x(i)
                  rv1 = rv1*rv1
               else
                  rv1 = 0.0_8
               endif

               rsum = rsum + rv1

               i = i + blockDim%x*blockDim%y
            end do

            ! Partial sum within warps using shuffle
            rv1 = rsum
            rv2 = __shfl_down(rv1, 1)
            rv1 = rv1 + rv2
            rv2 = __shfl_down(rv1, 2)
            rv1 = rv1 + rv2
            rv2 = __shfl_down(rv1, 4)
            rv1 = rv1 + rv2
            rv2 = __shfl_down(rv1, 8)
            rv1 = rv1 + rv2
            rv2 = __shfl_down(rv1, 16)
            rv1 = rv1 + rv2

            if (laneID == 1) then
               istat = atomicadd(xnorm, rv1)
            endif

            call syncthreads()

            if (xnorm == 0.0_8) then
               if (tid == 1) then
                  tau = 0.0_8
               endif
            else
               if (tid == 1) then
                  xnorm = sqrt(xnorm)
                  rv1 = abs(alphar)

                  ! not taking abs of xnorm
                  scal = max(rv1, xnorm)
                  scal2 = min(rv1, xnorm)

                  if (scal2 .eq. 0.0d0) then
                     beta = -sign(scal, alphar)
                  else
                     beta = -sign(scal*sqrt(1.0d0 + (scal2/scal)**2), alphar)
                  endif

                  tau = (beta - alphar)/beta

                  e = beta ! store beta in e vector
                  alpha_s = 1.d0/(alphar - beta) !scaling factor for dscal
               endif

               call syncthreads()

               do i = tid, N - 1, blockDim%x*blockDim%y

                  if (i <= N - 2) then
                     x(i) = alpha_s*x(i)
                  elseif (i == N - 1) then
                     x(i) = 1.0_8
                  endif

               end do

            endif

      CALL hipCheck(hipMemcpy(_v,c_loc(v),C_SIZEOF(v),hipMemcpyHostToDevice))
      CALL hipCheck(hipMemcpy(_w,c_loc(w),C_SIZEOF(w),hipMemcpyHostToDevice))
      CALL hipCheck(hipMemcpy(_w2,c_loc(w2),C_SIZEOF(w2),hipMemcpyHostToDevice))
      CALL hipCheck(hipMemcpy(_x,c_loc(x),C_SIZEOF(x),hipMemcpyHostToDevice))

    end subroutine

    subroutine launch_stacked_dgemv_t_cpu(m,&
        n,&
        ldv,&
        ldw,&
        _v,&
        v_n1,&
        v_n2,&
        v_lb1,&
        v_lb2,&
        _w,&
        w_n1,&
        w_n2,&
        w_lb1,&
        w_lb2,&
        _x,&
        x_n1,&
        x_lb1,&
        _z1,&
        z1_n1,&
        z1_lb1,&
        _z2,&
        z2_n1,&
        z2_lb1)
      use iso_c_binding
      use hip
      implicit none
      INTEGER(kind=),value :: m
      INTEGER(kind=),value :: n
      INTEGER(kind=),value :: ldv
      INTEGER(kind=),value :: ldw
      type(c_ptr),value :: _v
      integer(c_int),value,intent(IN) :: v_n1
      integer(c_int),value,intent(IN) :: v_n2
      integer(c_int),value,intent(IN) :: v_lb1
      integer(c_int),value,intent(IN) :: v_lb2
      type(c_ptr),value :: _w
      integer(c_int),value,intent(IN) :: w_n1
      integer(c_int),value,intent(IN) :: w_n2
      integer(c_int),value,intent(IN) :: w_lb1
      integer(c_int),value,intent(IN) :: w_lb2
      type(c_ptr),value :: _x
      integer(c_int),value,intent(IN) :: x_n1
      integer(c_int),value,intent(IN) :: x_lb1
      type(c_ptr),value :: _z1
      integer(c_int),value,intent(IN) :: z1_n1
      integer(c_int),value,intent(IN) :: z1_lb1
      type(c_ptr),value :: _z2
      integer(c_int),value,intent(IN) :: z2_n1
      integer(c_int),value,intent(IN) :: z2_lb1
            real(8), M), intent(in)  ,target :: v(v_n1,v_n2)
            real(8), M), intent(in)  ,target :: w(w_n1,w_n2)
            real(8), intent(in)       ,target :: x(x_n1)
            real(8),target :: z1(z1_n1)
            real(8),target :: z2(z2_n1)
      CALL hipCheck(hipMemcpy(c_loc(v),_v,C_SIZEOF(v),hipMemcpyDeviceToHost))
      CALL hipCheck(hipMemcpy(c_loc(w),_w,C_SIZEOF(w),hipMemcpyDeviceToHost))
      CALL hipCheck(hipMemcpy(c_loc(x),_x,C_SIZEOF(x),hipMemcpyDeviceToHost))
      CALL hipCheck(hipMemcpy(c_loc(z1),_z1,C_SIZEOF(z1),hipMemcpyDeviceToHost))
      CALL hipCheck(hipMemcpy(c_loc(z2),_z2,C_SIZEOF(z2),hipMemcpyDeviceToHost))
            use cudafor
            implicit none
            integer, value                                  :: M, N, ldv, ldw
            real(8), dimension(ldv, M), device, intent(in)  :: V
            real(8), dimension(ldw, M), device, intent(in)  :: W
            real(8), dimension(N), device, intent(in)       :: x
            real(8), dimension(M), device                   :: z1, z2
            !complex(8), dimension(M), device, intent(in)        :: z1, z2

            !real(8), dimension(32), shared                     :: r_s
            !real(8), dimension(32), shared                     :: i_s

            integer :: i, j, tx, ty, istat
            real(8) :: rv1, rv2, xr

            tx = threadIdx%x
            ty = threadIdx%y

            i = (blockIdx%y - 1)*blockDim%y + ty
            j = (blockIdx%x - 1)*blockDim%x + tx

            !if (i > 2*M .or. j > N) return
            if (i > 2*M) return

            xr = x(j)

            if (j > N) then
               rv1 = 0.d0
            else
               if (i > M) then
                  rv2 = W(j, i - M)
               else
                  rv2 = V(j, i)
               endif

               rv1 = rv2*xr
            endif

            !Partial sum within warps using shuffle
            rv2 = __shfl_down(rv1, 1)
            rv1 = rv1 + rv2
            rv2 = __shfl_down(rv1, 2)
            rv1 = rv1 + rv2
            rv2 = __shfl_down(rv1, 4)
            rv1 = rv1 + rv2
            rv2 = __shfl_down(rv1, 8)
            rv1 = rv1 + rv2
            rv2 = __shfl_down(rv1, 16)
            rv1 = rv1 + rv2

            if (tx == 1) then
               if (i > M) then
                  istat = atomicadd(z2(i - M), rv1)
               else
                  istat = atomicadd(z1(i), rv1)
               endif
            endif

            return
      CALL hipCheck(hipMemcpy(_v,c_loc(v),C_SIZEOF(v),hipMemcpyHostToDevice))
      CALL hipCheck(hipMemcpy(_w,c_loc(w),C_SIZEOF(w),hipMemcpyHostToDevice))
      CALL hipCheck(hipMemcpy(_x,c_loc(x),C_SIZEOF(x),hipMemcpyHostToDevice))
      CALL hipCheck(hipMemcpy(_z1,c_loc(z1),C_SIZEOF(z1),hipMemcpyHostToDevice))
      CALL hipCheck(hipMemcpy(_z2,c_loc(z2),C_SIZEOF(z2),hipMemcpyHostToDevice))

    end subroutine

    subroutine launch_stacked_dgemv_n_cpu(m,&
        n,&
        ldv,&
        ldw,&
        _v,&
        v_n1,&
        v_n2,&
        v_lb1,&
        v_lb2,&
        _w,&
        w_n1,&
        w_n2,&
        w_lb1,&
        w_lb2,&
        _z1,&
        z1_n1,&
        z1_lb1,&
        _z2,&
        z2_n1,&
        z2_lb1,&
        _y,&
        y_n1,&
        y_lb1)
      use iso_c_binding
      use hip
      implicit none
      INTEGER(kind=),value :: m
      INTEGER(kind=),value :: n
      INTEGER(kind=),value :: ldv
      INTEGER(kind=),value :: ldw
      type(c_ptr),value :: _v
      integer(c_int),value,intent(IN) :: v_n1
      integer(c_int),value,intent(IN) :: v_n2
      integer(c_int),value,intent(IN) :: v_lb1
      integer(c_int),value,intent(IN) :: v_lb2
      type(c_ptr),value :: _w
      integer(c_int),value,intent(IN) :: w_n1
      integer(c_int),value,intent(IN) :: w_n2
      integer(c_int),value,intent(IN) :: w_lb1
      integer(c_int),value,intent(IN) :: w_lb2
      type(c_ptr),value :: _z1
      integer(c_int),value,intent(IN) :: z1_n1
      integer(c_int),value,intent(IN) :: z1_lb1
      type(c_ptr),value :: _z2
      integer(c_int),value,intent(IN) :: z2_n1
      integer(c_int),value,intent(IN) :: z2_lb1
      type(c_ptr),value :: _y
      integer(c_int),value,intent(IN) :: y_n1
      integer(c_int),value,intent(IN) :: y_lb1
            real(8), N), intent(in)     ,target :: v(v_n1,v_n2)
            real(8), N), intent(in)     ,target :: w(w_n1,w_n2)
            real(8), intent(in)          ,target :: z1(z1_n1)
            real(8), intent(in)          ,target :: z2(z2_n1)
            real(8),target :: y(y_n1)
      CALL hipCheck(hipMemcpy(c_loc(v),_v,C_SIZEOF(v),hipMemcpyDeviceToHost))
      CALL hipCheck(hipMemcpy(c_loc(w),_w,C_SIZEOF(w),hipMemcpyDeviceToHost))
      CALL hipCheck(hipMemcpy(c_loc(z1),_z1,C_SIZEOF(z1),hipMemcpyDeviceToHost))
      CALL hipCheck(hipMemcpy(c_loc(z2),_z2,C_SIZEOF(z2),hipMemcpyDeviceToHost))
      CALL hipCheck(hipMemcpy(c_loc(y),_y,C_SIZEOF(y),hipMemcpyDeviceToHost))
            use cudafor
            implicit none
            integer, value                                     :: M, N, ldv, ldw
            real(8), dimension(ldv, N), device, intent(in)     :: V
            real(8), dimension(ldw, N), device, intent(in)     :: W
            real(8), dimension(N), device, intent(in)          :: z1, z2
            real(8), dimension(M), device                      :: y

            integer :: i, j, tx, ty, istat
            real(8) :: rv1, rv2, xr

            tx = threadIdx%x
            ty = threadIdx%y

            i = (blockIdx%x - 1)*blockDim%x + tx
            j = (blockIdx%y - 1)*blockDim%y + ty

            if (i > M .or. j > 2*N) return

            if (j > N) then
               xr = z2(j - N)
               rv2 = V(i, j - N)
            else
               xr = z1(j)
               rv2 = W(i, j)
            endif

            rv1 = -rv2*xr

            istat = atomicadd(y(i), rv1)

            return

      CALL hipCheck(hipMemcpy(_v,c_loc(v),C_SIZEOF(v),hipMemcpyHostToDevice))
      CALL hipCheck(hipMemcpy(_w,c_loc(w),C_SIZEOF(w),hipMemcpyHostToDevice))
      CALL hipCheck(hipMemcpy(_z1,c_loc(z1),C_SIZEOF(z1),hipMemcpyHostToDevice))
      CALL hipCheck(hipMemcpy(_z2,c_loc(z2),C_SIZEOF(z2),hipMemcpyHostToDevice))
      CALL hipCheck(hipMemcpy(_y,c_loc(y),C_SIZEOF(y),hipMemcpyHostToDevice))

    end subroutine

    subroutine launch_finish_w_col_kernel_cpu(n,&
        tau,&
        _x,&
        x_n1,&
        x_lb1,&
        _y,&
        y_n1,&
        y_lb1)
      use iso_c_binding
      use hip
      implicit none
      INTEGER(kind=),value :: n
      REAL(kind=8),value :: tau
      type(c_ptr),value :: _x
      integer(c_int),value,intent(IN) :: x_n1
      integer(c_int),value,intent(IN) :: x_lb1
      type(c_ptr),value :: _y
      integer(c_int),value,intent(IN) :: y_n1
      integer(c_int),value,intent(IN) :: y_lb1
            real(8), intent(in)    ,target :: x(x_n1)
            real(8),target :: y(y_n1)
      CALL hipCheck(hipMemcpy(c_loc(x),_x,C_SIZEOF(x),hipMemcpyDeviceToHost))
      CALL hipCheck(hipMemcpy(c_loc(y),_y,C_SIZEOF(y),hipMemcpyDeviceToHost))
            implicit none
            integer, value                               :: N
            real(8), device                              :: tau
            real(8), dimension(N), device, intent(in)    :: x
            real(8), dimension(N), device                :: y

            integer                                      :: tid, i, j, k, nb, istat, laneID
            real(8)                                      :: rv1, rv2, rsum, mytau

            real(8), shared                              :: alphar
            !real(8), shared                              :: alpha
            real(8)                                      :: alpha

            tid = threadIdx%x
            laneID = iand(tid, 31)

            if (tid == 1) then
               alphar = 0.0_8
            endif

            call syncthreads()

            rsum = 0.0_8
            mytau = tau

            nb = ceiling(real(N)/blockDim%x) ! number of blocks down column

            i = tid
            do j = 1, nb

               ! All threads perform their product, zero if out of bounds
               if (i <= N) then
                  rv1 = mytau*y(i)*x(i)
               else
                  rv1 = 0.0d0
               endif

               rsum = rsum + rv1

               i = i + blockDim%x

            end do

            ! Partial sum within warps using shuffle
            rv1 = rsum
            rv2 = __shfl_down(rv1, 1)
            rv1 = rv1 + rv2
            rv2 = __shfl_down(rv1, 2)
            rv1 = rv1 + rv2
            rv2 = __shfl_down(rv1, 4)
            rv1 = rv1 + rv2
            rv2 = __shfl_down(rv1, 8)
            rv1 = rv1 + rv2
            rv2 = __shfl_down(rv1, 16)
            rv1 = rv1 + rv2

            if (laneID == 1) then
               istat = atomicadd(alphar, rv1)
            endif

            call syncthreads()

            alpha = -0.5d0*mytau*alphar

            do i = tid, N, blockDim%x
               y(i) = mytau*y(i) + alpha*x(i) !daxpy
            end do

      CALL hipCheck(hipMemcpy(_x,c_loc(x),C_SIZEOF(x),hipMemcpyHostToDevice))
      CALL hipCheck(hipMemcpy(_y,c_loc(y),C_SIZEOF(y),hipMemcpyHostToDevice))

    end subroutine

    subroutine launch_stacked_dgemv_n_finish_w_cpu(m,&
        n,&
        ldv,&
        ldw,&
        _v,&
        v_n1,&
        v_n2,&
        v_lb1,&
        v_lb2,&
        _w,&
        w_n1,&
        w_n2,&
        w_lb1,&
        w_lb2,&
        _z1,&
        z1_n1,&
        z1_lb1,&
        _z2,&
        z2_n1,&
        z2_lb1,&
        _y,&
        y_n1,&
        y_lb1,&
        tau,&
        _x,&
        x_n1,&
        x_lb1,&
        finished)
      use iso_c_binding
      use hip
      implicit none
      INTEGER(kind=),value :: m
      INTEGER(kind=),value :: n
      INTEGER(kind=),value :: ldv
      INTEGER(kind=),value :: ldw
      type(c_ptr),value :: _v
      integer(c_int),value,intent(IN) :: v_n1
      integer(c_int),value,intent(IN) :: v_n2
      integer(c_int),value,intent(IN) :: v_lb1
      integer(c_int),value,intent(IN) :: v_lb2
      type(c_ptr),value :: _w
      integer(c_int),value,intent(IN) :: w_n1
      integer(c_int),value,intent(IN) :: w_n2
      integer(c_int),value,intent(IN) :: w_lb1
      integer(c_int),value,intent(IN) :: w_lb2
      type(c_ptr),value :: _z1
      integer(c_int),value,intent(IN) :: z1_n1
      integer(c_int),value,intent(IN) :: z1_lb1
      type(c_ptr),value :: _z2
      integer(c_int),value,intent(IN) :: z2_n1
      integer(c_int),value,intent(IN) :: z2_lb1
      type(c_ptr),value :: _y
      integer(c_int),value,intent(IN) :: y_n1
      integer(c_int),value,intent(IN) :: y_lb1
      REAL(kind=8),value :: tau
      type(c_ptr),value :: _x
      integer(c_int),value,intent(IN) :: x_n1
      integer(c_int),value,intent(IN) :: x_lb1
      INTEGER(kind=),value :: finished
            real(8), N), intent(in)     ,target :: v(v_n1,v_n2)
            real(8), N), intent(in)     ,target :: w(w_n1,w_n2)
            real(8), intent(in)          ,target :: z1(z1_n1)
            real(8), intent(in)          ,target :: z2(z2_n1)
            real(8),target :: y(y_n1)
            real(8), intent(in)          ,target :: x(x_n1)
      CALL hipCheck(hipMemcpy(c_loc(v),_v,C_SIZEOF(v),hipMemcpyDeviceToHost))
      CALL hipCheck(hipMemcpy(c_loc(w),_w,C_SIZEOF(w),hipMemcpyDeviceToHost))
      CALL hipCheck(hipMemcpy(c_loc(z1),_z1,C_SIZEOF(z1),hipMemcpyDeviceToHost))
      CALL hipCheck(hipMemcpy(c_loc(z2),_z2,C_SIZEOF(z2),hipMemcpyDeviceToHost))
      CALL hipCheck(hipMemcpy(c_loc(y),_y,C_SIZEOF(y),hipMemcpyDeviceToHost))
      CALL hipCheck(hipMemcpy(c_loc(x),_x,C_SIZEOF(x),hipMemcpyDeviceToHost))
            use cudafor
            implicit none
            integer, value                                     :: M, N, ldv, ldw
            real(8), dimension(ldv, N), device, intent(in)     :: V
            real(8), dimension(ldw, N), device, intent(in)     :: W
            real(8), dimension(N), device, intent(in)          :: z1, z2
            real(8), dimension(M), device                      :: y
            real(8), device                                    :: tau
            real(8), dimension(M), device, intent(in)          :: x
            integer, device                                    :: finished

            integer :: i, j, tx, ty, istat, nBlocks, tid, laneID, nb
            integer, shared :: nFinished
            real(8) :: rv1, rv2, rsum, xr, mytau
            real(8), shared                              :: alphar
            !real(8), shared                              :: alpha
            real(8)                                      :: alpha

            tx = threadIdx%x
            ty = threadIdx%y

            i = (blockIdx%x - 1)*blockDim%x + tx
            j = (blockIdx%y - 1)*blockDim%y + ty

            nBlocks = gridDim%x*gridDim%y

            if (i <= M .and. j <= 2*N) then

               if (j > N) then
                  xr = z2(j - N)
                  rv2 = V(i, j - N)
               else
                  xr = z1(j)
                  rv2 = W(i, j)
               endif

               rv1 = -rv2*xr

               istat = atomicadd(y(i), rv1)
            endif

            call threadfence()

            nFinished = 0
            call syncthreads()
            if (tx + ty == 2) nFinished = atomicinc(finished, nBlocks - 1)
            call syncthreads()

            if (nFinished < nBlocks - 1) return

            ! Begin finish_W_col work with last block
            tid = threadIdx%x + (threadIdx%y - 1)*blockDim%x
            laneID = iand(tid, 31)

            if (tid == 1) then
               alphar = 0.0_8
            endif

            call syncthreads()

            rsum = 0.0_8
            mytau = tau

            nb = ceiling(real(M)/(blockDim%x*blockDim%y)) ! number of blocks down column

            i = tid
            do j = 1, nb

               ! All threads perform their product, zero if out of bounds
               if (i <= M) then
                  rv1 = mytau*y(i)*x(i)
               else
                  rv1 = 0.0d0
               endif

               rsum = rsum + rv1

               i = i + blockDim%x*blockDim%y

            end do

            ! Partial sum within warps using shuffle
            rv1 = rsum
            rv2 = __shfl_down(rv1, 1)
            rv1 = rv1 + rv2
            rv2 = __shfl_down(rv1, 2)
            rv1 = rv1 + rv2
            rv2 = __shfl_down(rv1, 4)
            rv1 = rv1 + rv2
            rv2 = __shfl_down(rv1, 8)
            rv1 = rv1 + rv2
            rv2 = __shfl_down(rv1, 16)
            rv1 = rv1 + rv2

            if (laneID == 1) then
               istat = atomicadd(alphar, rv1)
            endif

            call syncthreads()

            alpha = -0.5d0*mytau*alphar

            do i = tid, M, blockDim%x*blockDim%y
               y(i) = mytau*y(i) + alpha*x(i) !daxpy
            end do

      CALL hipCheck(hipMemcpy(_v,c_loc(v),C_SIZEOF(v),hipMemcpyHostToDevice))
      CALL hipCheck(hipMemcpy(_w,c_loc(w),C_SIZEOF(w),hipMemcpyHostToDevice))
      CALL hipCheck(hipMemcpy(_z1,c_loc(z1),C_SIZEOF(z1),hipMemcpyHostToDevice))
      CALL hipCheck(hipMemcpy(_z2,c_loc(z2),C_SIZEOF(z2),hipMemcpyHostToDevice))
      CALL hipCheck(hipMemcpy(_y,c_loc(y),C_SIZEOF(y),hipMemcpyHostToDevice))
      CALL hipCheck(hipMemcpy(_x,c_loc(x),C_SIZEOF(x),hipMemcpyHostToDevice))

    end subroutine


end module dsytrd_gpu_kernels