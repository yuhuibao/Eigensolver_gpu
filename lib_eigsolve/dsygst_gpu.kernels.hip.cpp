// This file was generated by gpufort

#include "hip/hip_complex.h"
#include "hip/hip_runtime.h"
#include "hip/math_functions.h"
#include <cstdio>

namespace {
// make float
float make_float(short int a) { return static_cast<float>(a); }
float make_float(unsigned short int a) { return static_cast<float>(a); }
float make_float(unsigned int a) { return static_cast<float>(a); }
float make_float(int a) { return static_cast<float>(a); }
float make_float(long int a) { return static_cast<float>(a); }
float make_float(unsigned long int a) { return static_cast<float>(a); }
float make_float(long long int a) { return static_cast<float>(a); }
float make_float(unsigned long long int a) { return static_cast<float>(a); }
float make_float(signed char a) { return static_cast<float>(a); }
float make_float(unsigned char a) { return static_cast<float>(a); }
float make_float(float a) { return static_cast<float>(a); }
float make_float(double a) { return static_cast<float>(a); }
float make_float(long double a) { return static_cast<float>(a); }
float make_float(hipFloatComplex &a) { return static_cast<float>(a.x); }
float make_float(hipDoubleComplex &a) { return static_cast<float>(a.x); }
// make double
double make_double(short int a) { return static_cast<double>(a); }
double make_double(unsigned short int a) { return static_cast<double>(a); }
double make_double(unsigned int a) { return static_cast<double>(a); }
double make_double(int a) { return static_cast<double>(a); }
double make_double(long int a) { return static_cast<double>(a); }
double make_double(unsigned long int a) { return static_cast<double>(a); }
double make_double(long long int a) { return static_cast<double>(a); }
double make_double(unsigned long long int a) { return static_cast<double>(a); }
double make_double(signed char a) { return static_cast<double>(a); }
double make_double(unsigned char a) { return static_cast<double>(a); }
double make_double(float a) { return static_cast<double>(a); }
double make_double(double a) { return static_cast<double>(a); }
double make_double(long double a) { return static_cast<double>(a); }
double make_double(hipFloatComplex &a) { return static_cast<double>(a.x); }
double make_double(hipDoubleComplex &a) { return static_cast<double>(a.x); }
// conjugate complex type
hipFloatComplex conj(hipFloatComplex &c) { return hipConjf(c); }
hipDoubleComplex conj(hipDoubleComplex &z) { return hipConj(z); }

// TODO Add the following functions:
// - sign(x,y) = sign(y) * |x| - sign transfer function
// ...
} // namespace
#define divideAndRoundUp(x, y) ((x) / (y) + ((x) % (y) != 0))

// BEGIN krnl_afb01f_0
/* Fortran original:
        ! kernel do(2)<<<*,*, 0, stream1>>>
        do j = k, k + kb - 1
           do i = k, k + kb - 1
              if (j < i) then
                 A(i, j) = A(j, i)
              endif
           end do
        end do

*/
// NOTE: The following information was given in the orignal Cuf kernel pragma:
// - Nested outer-most do-loops that are directly mapped to threads: 2
// - Number of blocks (CUDA): -1-1-1._ ('-1' means not specified)
// - Threads per block (CUDA): -1-1-1._ ('-1' means not specified)
// - Shared Memory: 0
// - Stream: stream1

__global__ void krnl_afb01f_0(int kb, double *a, const int a_n1, const int a_n2, const int a_lb1, const int a_lb2, int k) {
#undef _idx_a
#define _idx_a(a, b) ((a - (a_lb1)) + a_n1 * (b - (a_lb2)))

  unsigned int j = k + threadIdx.y + blockIdx.y * blockDim.y;
  unsigned int i = k + threadIdx.x + blockIdx.x * blockDim.x;
  if ((j <= (k + kb - 1)) && (i <= (k + kb - 1))) {
    if ((j < i)) {
      a[_idx_a(i, j)] = a[_idx_a(j, i)];
    }
  }
}

extern "C" void launch_krnl_afb01f_0(dim3 *grid,
                                     dim3 *block,
                                     const int sharedMem,
                                     hipStream_t stream,
                                     int kb,
                                     double *a,
                                     const int a_n1,
                                     const int a_n2,
                                     const int a_lb1,
                                     const int a_lb2,
                                     int k) {
  hipLaunchKernelGGL((krnl_afb01f_0), *grid, *block, sharedMem, stream, kb, a, a_n1, a_n2, a_lb1, a_lb2, k);
}
extern "C" void launch_krnl_afb01f_0_auto(const int sharedMem,
                                          hipStream_t stream,
                                          int kb,
                                          double *a,
                                          const int a_n1,
                                          const int a_n2,
                                          const int a_lb1,
                                          const int a_lb2,
                                          int k) {
  const unsigned int krnl_afb01f_0_NX = kb;
  const unsigned int krnl_afb01f_0_NY = kb;

  const unsigned int krnl_afb01f_0_blockX = 16;
  const unsigned int krnl_afb01f_0_blockY = 16;

  const unsigned int krnl_afb01f_0_gridX = divideAndRoundUp(krnl_afb01f_0_NX, krnl_afb01f_0_blockX);
  const unsigned int krnl_afb01f_0_gridY = divideAndRoundUp(krnl_afb01f_0_NY, krnl_afb01f_0_blockY);

  dim3 grid(krnl_afb01f_0_gridX, krnl_afb01f_0_gridY);
  dim3 block(krnl_afb01f_0_blockX, krnl_afb01f_0_blockY);
  hipLaunchKernelGGL((krnl_afb01f_0), grid, block, sharedMem, stream, kb, a, a_n1, a_n2, a_lb1, a_lb2, k);
}
// END krnl_afb01f_0
